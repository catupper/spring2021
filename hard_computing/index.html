<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>計算困難問題 - K-kai Hackathon Spring 2021</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">K-kai Hackathon Spring 2021</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../lang_processor/" class="nav-link">言語処理系</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">計算困難問題</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../lang_processor/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#_1" class="nav-link">計算困難問題</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">計算困難問題とは</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">巡回セールスマン問題</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_11" class="nav-link">ナップザック問題</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_16" class="nav-link">計算困難問題に対するアルゴリズム</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_21" class="nav-link">近似アルゴリズム</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">計算困難問題</h1>
<h2 id="_2">計算困難問題とは</h2>
<p>計算困難問題(hard computing problem)は、計算にとても時間がかかる問題である。
まずは、計算にかかる時間という概念をもう少し厳密に扱うために、計算量という概念を説明しよう。</p>
<h3 id="_3">計算量</h3>
<p>計算量というのは、ある問題を解くときにプログラムが実行する計算の回数を示す量である。</p>
<p>例えば1から100までの整数の総和を求めるとしよう。
最も単純な方法として、素直に99回足し算を行う方法がある。文字通り99回の計算が行われる。
それに対して、等差数列の和の公式((初項 + 末項)×項数 ÷2)を利用すれば、たかだか3回の計算で総和を求めることができる。
もしこれが100までではなくて <span class="arithmatex">\(n\)</span> までだとしたらどうなるだろうか。
素直に全部足し合わせる方法だと計算回数は <span class="arithmatex">\(n-1\)</span> 回になり、公式を使う場合だと、どんな <span class="arithmatex">\(n\)</span> に対しても3回となる。
この <span class="arithmatex">\(n-1\)</span> や <span class="arithmatex">\(3\)</span> がそれぞれのアルゴリズムの計算量である。
計算量を表す際は細かい数字より、最も支配的な項だけを抜き出すために、<span class="arithmatex">\(\Theta\)</span>記法や<span class="arithmatex">\(O\)</span>記法を使う。</p>
<h3 id="o">Θ記法,O記法</h3>
<p><strong>Θ記法</strong>は関数の種類を表す記法である。<span class="arithmatex">\(f(x) = \Theta(g(x))\)</span>と書くことによって、<span class="arithmatex">\(f(x)\)</span> は <span class="arithmatex">\(g(x)\)</span> と同等のスケールで大きくなる関数だ、ということを表す。ここで、「同等のスケール」というのは、<span class="arithmatex">\(x\)</span> を無限に大きくしていった時に、<span class="arithmatex">\(f(x)\)</span> と <span class="arithmatex">\(g(x)\)</span> の比が <span class="arithmatex">\(0\)</span> に収束せず、また有る定数を超えることがない、ということを表す。
以下の例を見て、<span class="arithmatex">\(\Theta\)</span> 記法のイメージを掴んで欲しい。</p>
<ul>
<li><span class="arithmatex">\(x^2+2x+4 = Θ(x^2)\)</span></li>
<li><span class="arithmatex">\(500x^3 + 10x- 2000000 + 1/x = Θ(x^3)\)</span></li>
<li><span class="arithmatex">\((x+4)^10 = Θ(x^{10})\)</span></li>
<li><span class="arithmatex">\(2^x + x^3 = Θ(2^x)\)</span></li>
<li><span class="arithmatex">\(0.8^x + x^3 - \sin(x) = Θ(x^3)\)</span></li>
</ul>
<p><strong>O記法</strong>はΩ記法の仲間である。<span class="arithmatex">\(f(x) = O(g(x))\)</span> と書くことによって、<span class="arithmatex">\(f(x)\)</span> は <span class="arithmatex">\(g(x)\)</span> と同等かそれより小さいスケールで大きくなることを表す。<span class="arithmatex">\(f(x) &lt; h(x), h(x) = Θ(g(x))\)</span> となる <span class="arithmatex">\(h(x)\)</span> が存在するなら、<span class="arithmatex">\(f(x)=O(g(x))\)</span> である。
Θ記法が「イコール」に対応するなら、O記法は「小なりイコール」に対応すると考えてもらって良い。</p>
<h3 id="_4">多項式時間、指数時間</h3>
<p>ある種類の問題を解くアルゴリズムが、問題に出てくるデータのサイズに対してどれくらいの計算量がかかるか、というのが計算機科学の興味である。
たとえば、「整数がN個与えられて、その総和を求める愚直なアルゴリズムの計算量は <span class="arithmatex">\(O(N)\)</span> である」とか「整数がN個与えられて、和が0になる3つ組が存在するかどうかは <span class="arithmatex">\(O(N^2)\)</span> の計算量で判定できる」というふうにアルゴリズムの計算量を議論する。</p>
<p>ある問題を解くアルゴリズムが、問題のサイズNに対して、ある多項式f(N)が存在して、 <span class="arithmatex">\(O(f(N))\)</span> の時間で動作するとき、そのアルゴリズムは<strong>多項式時間アルゴリズム</strong>と呼ぶ。
また、 <span class="arithmatex">\(f(N)\)</span> が指数関数の時は<strong>指数時間アルゴリズム</strong>と呼ぶ。</p>
<h3 id="_5">計算困難問題</h3>
<p>これから扱っていく計算困難問題は、<strong>指数時間アルゴリズム</strong>は見つかっているが、<strong>多項式時間アルゴリズム</strong>は見つかっていない、あるいは無いと予想されている問題である。
代表的な問題として充足可能性問題(SAT)や巡回セールスマン問題(TSP)などがある。
まずは、多項式時間では解けないとされている問題の中でも特に有名な<strong>巡回セールスマン問題</strong>を見ていこう。</p>
<h2 id="_6">巡回セールスマン問題</h2>
<p>巡回セールスマン問題(travelling salesman problem)とは以下の形式の問題である。</p>
<p>「 <span class="arithmatex">\(N\)</span> 個の街がある。 <span class="arithmatex">\(i\)</span> 番目の街と <span class="arithmatex">\(j\)</span> 番目の街は距離 <span class="arithmatex">\(d_{i,j}\)</span> の道で結ばれている。0番目の街から開始して、全ての街をちょうど1回ずつ通ってもう一度０0目の街に帰ってくるルートのうち、総移動距離が最小のものを求めよ。」</p>
<p>まずはこの問題の様々な解法を実装して速さを比べてみよう。</p>
<h3 id="_7">入力形式</h3>
<p>この先、巡回セールスマン問題を解くアルゴリズムをいくつか紹介し、実装もする。それにあたって、どのような形式で問題が与えられるかを決めておかないと不便である。
全ての実装において、標準入力から、以下の形式で問題を受け取るということにする。</p>
<div class="highlight"><pre><span></span><code>N
d_0,0 d_0,1 d_0,2 .. d_0,N-1
d_1,0 d_1,1 d_1,2 .. d_1,N-1
:
d_N-1,0 d_N-1,1 d_N-1,2 .. d_N-1,N-1
</code></pre></div>

<p>つまり、最初の1行には巡回する街の個数が書かれており、続く <span class="arithmatex">\(N\)</span> 行にはそれぞれ <span class="arithmatex">\(N\)</span> 個の数字が書かれており、 <span class="arithmatex">\(i\)</span> 行 <span class="arithmatex">\(j\)</span> 列目は街 <span class="arithmatex">\(i\)</span> と街 <span class="arithmatex">\(j\)</span> の距離が書かれている。</p>
<p>また、以下の制約も課すことにする。</p>
<ul>
<li><span class="arithmatex">\(d_{i,j}\)</span> は非負整数</li>
<li><span class="arithmatex">\(d_{i,i} = 0\)</span></li>
<li>iとjの距離はjとiの距離と等しい</li>
<li>入力や答えは <span class="arithmatex">\(10^{10}\)</span> を超えない</li>
</ul>
<p>以下に入力を受け取って、二次元配列dに各街の間の距離を格納する関数のpythonでの実行を挙げる。他の言語を使っている人は適宜実装しなおしてほしい。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">d</span>
</code></pre></div>

<p>この部分はどのアルゴリズムでも使用するので、どこかに別名で保存しておくと良いだろう。</p>
<h3 id="_8">全探索</h3>
<p>まずは、最もシンプルな全探索アルゴリズムを見ていこう。これは街をめぐる順序を全通り試すというものである。
0番目以外の街を何らかの順番で1回ずつ通るルートは全部で <span class="arithmatex">\((N-1)!\)</span> 通りある。うまい具合にこれらを列挙して、その中で最も距離が短いものを返せば、巡回セールスマン問題は解ける。
ルートを一つ決めたとき、そのルートの総移動距離は <span class="arithmatex">\(O(N)\)</span> で求まるので、このアルゴリズムの計算量は <span class="arithmatex">\(O(N!)\)</span> となる。これは指数時間アルゴリズムですらなく、とても遅いアルゴリズムになるが、実装は簡単で、正当性が明らかなので、試しに実装するにはちょうどよい。</p>
<p>以下に全探索プログラムを挙げる。</p>
<div class="highlight"><pre><span></span><code><span class="n">INF</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">10</span> <span class="c1">#無限大の代わり</span>
<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">next_permutation</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">l</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">route</span> <span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">INF</span>
    <span class="n">min_route</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">distance</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">route</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">min_route</span> <span class="o">=</span> <span class="n">route</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">next_permutation</span><span class="p">(</span><span class="n">route</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;route&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">min_route</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p><code>next_permutation(l)</code>関数はリストlを受け取って、lをひとつ次の順列に変換する関数である。戻り値は、変換に成功したかどうかである。
ｌを昇順にソートされたリストとして、<code>next_permutation(l)</code>に順次かけていくと、全ての順列を経由した後に、降順にソートされて終了する。
<code>next_permutation</code>の実装はとても難解なので、よく読んで理解しよう。</p>
<p>実装ができたら試しに、以下の入力で動作を確認すると良い。</p>
<div class="highlight"><pre><span></span><code>4
0 1 1 2
1 0 2 3
1 2 0 4
2 3 4 0
</code></pre></div>

<p>うまく動けば以下のルートが得られるはずだ</p>
<div class="highlight"><pre><span></span><code>dist 8
route [0, 2, 1, 3, 0]
</code></pre></div>

<h3 id="_9">動的計画法</h3>
<p>全探索をすると、計算量が指数どころか階乗になってしまい、とても遅い。まずは代表的な指数時間アルゴリズムである動的計画法を実装してみよう。</p>
<p>動的計画法のアイデアは、「頂点0から出発して、頂点集合Vを経由し、頂点iに来るときの最短経路を求める」という部分問題を解くということである。</p>
<p>上のカギカッコで囲まれた部分の答えとなる値をdp[V][i]としよう。このときiはVに含まれるとする。
Vからiを取り除いた頂点集合をWとしよう。すると</p>
<p><span class="arithmatex">\(dp[V][i] = min_{j \in W} {dp[W][j] + d[j][i]}\)</span></p>
<p>が、成立する。これはiに訪れる一つ前の頂点について全探索していることになる。
Vのサイズが小さい順にdp配列を埋めていけば、全ての要素がO(N)で求めることができる。
dp配列のサイズはO(N2^N)なので、全部でO(N^2 2^N)でこのアルゴリズムは動作する。</p>
<p>以下にその実装を示す。</p>
<div class="highlight"><pre><span></span><code><span class="n">INF</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">10</span> <span class="c1">#無限大の代わり</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">))</span><span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">INF</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dp</span><span class="p">[(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>これも、全探索にある入力例で動作確認をすると良いだろう。</p>
<h4 id="_10">演習</h4>
<p>上の実装では最短経路の距離しか表示されない。その距離を実現する最短経路も一緒に表示するように改変してみよ。
(Hint:dp[V][i]が最後に更新された時のjを覚えておくと良い)</p>
<h2 id="_11">ナップザック問題</h2>
<p>ナップザック問題(Knapsack problem)とは以下の形式の問題である。</p>
<p>「 <span class="arithmatex">\(N\)</span> 個のお菓子と重量制限 <span class="arithmatex">\(W\)</span> のナップザックがある。 <span class="arithmatex">\(i\)</span> 番目のお菓子の価値は <span class="arithmatex">\(V_i\)</span> で重さは <span class="arithmatex">\(W_i\)</span> である。重さの総和が <span class="arithmatex">\(W\)</span> を超えないようにナップザックにお菓子を詰め込むとき、ナップザックの中のお菓子の価値の総和を最大化せよ。」
この問題も全探索と、動的計画法で解いてみよう。</p>
<h3 id="_12">入力形式</h3>
<p>ナップザック問題は、全ての実装において、標準入力から、以下の形式で問題を受け取るということにする。</p>
<div class="highlight"><pre><span></span><code>N　W
v_0 w_0
v_1 w_1
:
v_N-1 w_N-1
</code></pre></div>

<p>つまり、最初の1行にはスナックの個数が書かれており、続く <span class="arithmatex">\(N\)</span> 行にはそれぞれ <span class="arithmatex">\(i\)</span> 番目のスナックの価値と重さが書かれている。</p>
<p>また、以下の制約も課すことにする。</p>
<ul>
<li><span class="arithmatex">\(v_i, w_i\)</span> は非負整数</li>
<li>入力や答えは <span class="arithmatex">\(10^{18}\)</span> を超えない</li>
</ul>
<p>以下に入力を受け取って、二次元配列dに各街の間の距離を格納する関数のpythonでの実行を挙げる。他の言語を使っている人は適宜実装しなおしてほしい。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span><span class="n">W</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span>
</code></pre></div>

<p>この部分はどのアルゴリズムでも使用するので、どこかに別名で保存しておくと良いだろう。</p>
<h3 id="_13">全探索アルゴリズム</h3>
<p>まずは、どのお菓子を使って、どのお菓子を使わないかの組み合わせを全通り試す全探索を実装しよう。
お菓子の組み合わせは巡回セールスマン問題と同様に二進数を使って表そう。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">snacks</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">vsum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="k">continue</span>
            <span class="n">vsum</span> <span class="o">+=</span> <span class="n">vs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">wsum</span> <span class="o">+=</span> <span class="n">ws</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wsum</span> <span class="o">&gt;</span> <span class="n">W</span><span class="p">:</span><span class="k">continue</span>
        <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">vsum</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">vsum</span>
            <span class="n">snacks</span> <span class="o">=</span> <span class="n">used</span><span class="p">[:]</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;snacks&quot;</span><span class="p">,</span> <span class="n">snacks</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">brute_force</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>この前探索のアルゴリズムは、iに関するfor文が <span class="arithmatex">\(O(2^N)\)</span> 回ループし、中のjに関するfor文が <span class="arithmatex">\(O(N)\)</span> 回ループするので、 <span class="arithmatex">\(O(NN^2)\)</span> の計算量である。
これは指数時間アルゴリズムである。</p>
<p>実装ができたら試しに、以下の入力で動作を確認すると良い。</p>
<div class="highlight"><pre><span></span><code>5 8
7 2
11 3
11 3
13 4
28 7
</code></pre></div>

<h3 id="_14">動的計画法</h3>
<p>ナップザック問題における動的計画法のアイデアは、「 <span class="arithmatex">\(i\)</span> 番目のお菓子までの中からいくつかを選んで重さの総和が <span class="arithmatex">\(j\)</span> になる組わせの価値の総和の最大値は何か」という部分問題を解くことである。</p>
<p>上のカギカッコで囲まれた部分の答えとなる値をdp[i][j]としよう。すると</p>
<p><span class="arithmatex">\(dp[i][j] = max(dp[i-1][j], dp[i-1][j-w_i] + v_i)\)</span></p>
<p>が、成立する。iが小さい順にdp配列を埋めていけば、全ての要素がO(1)で求めることができる。
dp配列のサイズはO(NW)なので、全部でO(NW)でこのアルゴリズムは動作する。</p>
<p>一見これは多項式時間アルゴリズムに見えるが、Wは入力のサイズとは関係ない値なので（強いて言うならばその桁数が入力のサイズとなるので、指数オーダーで大きくなる値)、多項式時間アルゴリズムではない。
これは<strong>擬多項式時間アルゴリズム</strong>である。</p>
<p>以下に実装を示す</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">dynamic_programming</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">dynamic_programming</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<h4 id="_15">演習</h4>
<p>上の実装では最適解が表示されるだけで、ナップサックに入れるお菓子は表示されない。表示されるように書きなおしてみよ。</p>
<h2 id="_16">計算困難問題に対するアルゴリズム</h2>
<p>巡回セールスマン問題でもナップサック問題でも、動的計画法は全探索よりは速く動いたがそれでも指数時間アルゴリズムなので大きなサイズの問題を解くのには時間がかかりすぎてしまう。
しかし、必ず正しい最短巡回路長を返すアルゴリズムで多項式時間であるものは未だに見つかっていない。そのようなものは存在しないという予想さえある。</p>
<p>ここで、最適解より少し悪いかもしれないが、そんなに悪くない解を出すことが保証されていたり、経験的にわかっていたりするアルゴリズムをいくつか紹介する。</p>
<h3 id="_17">山登り法</h3>
<p>山登り法は、最適ではないかもしれない解から出発して、解が改善するように小さな変化をつけていく、これ以上どう変化させても解は改善しないという状態まで持っていくアルゴリズムである。
ナップザック問題の場合、「適当にお菓子を詰め込んだ後、まだ詰め込んでないものをひとつ選んで、それを詰め込めるように別のお菓子を適当に取り出す。この詰め替えでお菓子の価値の和が増えるなら、この詰替えを実施し、そうでないなら実施しない」というのを何度もやることは山登り法になる。
以下に山登り法でナップザック問題を解くpythonプログラムを示す。</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">climb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">trial</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">):</span>
    <span class="n">snacks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">knapsack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
        <span class="n">cand</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">snacks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">snack</span> <span class="o">=</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">W</span> <span class="o">-</span> <span class="n">wsum</span> <span class="o">&gt;=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]:</span>
            <span class="n">knapsack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>
            <span class="n">vsum</span> <span class="o">+=</span> <span class="n">vs</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
            <span class="n">wsum</span> <span class="o">+=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">tw</span> <span class="o">=</span> <span class="n">wsum</span>
        <span class="n">tv</span> <span class="o">=</span> <span class="n">vsum</span>
        <span class="n">tk</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">[:]</span>
        <span class="n">go_back</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">W</span> <span class="o">-</span> <span class="n">tw</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
            <span class="n">go_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">tk</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
            <span class="n">tw</span> <span class="o">-=</span> <span class="n">ws</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
            <span class="n">tv</span> <span class="o">-=</span> <span class="n">vs</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
        <span class="n">tw</span> <span class="o">+=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
        <span class="n">tv</span> <span class="o">+=</span> <span class="n">vs</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
        <span class="n">tk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tv</span> <span class="o">&gt;</span> <span class="n">vsum</span><span class="p">:</span>
            <span class="n">vsum</span> <span class="o">=</span> <span class="n">tv</span>
            <span class="n">wsum</span> <span class="o">=</span> <span class="n">tw</span>
            <span class="n">knapsack</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[:]</span>
            <span class="n">snacks</span> <span class="o">+=</span> <span class="n">go_back</span>
            <span class="k">del</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">vsum</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;snacks&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">knapsack</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">climb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>山登り法は、最適解の到着するまで動かし続ければ良いのだが、最適解じゃないところにとどまってしまったり、そもそも最適解かどうかの判定が難しかったりするので、通常は何回ループを回すかを指定して動かすことが多い。
そのため、最適解が得られる保証は無いが、プログラムが走る時間を自由に調節することができる。</p>
<h4 id="_18">演習(興味があれば)</h4>
<p>巡回セールスマン問題を山登り法で解くアルゴリズムを実装してみよ。
巡回セールスマン問題における山登りの例として、適当な2つの街の訪れる順序の入れ替えを、経路長が改善されたら実施し、そうでないなら実施しないというのを何回も行うものである。</p>
<h3 id="_19">焼きなまし法</h3>
<p>焼きなまし法は、山登り法を改良したものである。山登り法は、とにかく解が良くなる方向に進み続ける方針であるが、局所的に最適だが、全体としては最適ではない解にとどまってしまうことが有る。
そこで、低確率で解が悪くなる方向にも進むようにするというのが焼きなまし法である。実装はほとんど山登り法と同じだが、変更を加えるか加えないかの判断の条件式が少し増える。</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="k">def</span> <span class="nf">anealing</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">trial</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">):</span>
    <span class="n">snacks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">knapsack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ansknapsack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
        <span class="n">cand</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">snacks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">snack</span> <span class="o">=</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">W</span> <span class="o">-</span> <span class="n">wsum</span> <span class="o">&gt;=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]:</span>
            <span class="n">knapsack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>
            <span class="n">vsum</span> <span class="o">+=</span> <span class="n">vs</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
            <span class="n">wsum</span> <span class="o">+=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">tw</span> <span class="o">=</span> <span class="n">wsum</span>
        <span class="n">tv</span> <span class="o">=</span> <span class="n">vsum</span>
        <span class="n">tk</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">[:]</span>
        <span class="n">go_back</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">W</span> <span class="o">-</span> <span class="n">tw</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
            <span class="n">go_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">tk</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
            <span class="n">tw</span> <span class="o">-=</span> <span class="n">ws</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
            <span class="n">tv</span> <span class="o">-=</span> <span class="n">vs</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
        <span class="n">tw</span> <span class="o">+=</span> <span class="n">ws</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
        <span class="n">tv</span> <span class="o">+=</span> <span class="n">vs</span><span class="p">[</span><span class="n">snack</span><span class="p">]</span>
        <span class="n">tk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tv</span> <span class="o">&gt;</span> <span class="n">vsum</span> <span class="ow">or</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">trial</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">trial</span><span class="o">/</span><span class="n">_</span><span class="p">):</span>
            <span class="n">vsum</span> <span class="o">=</span> <span class="n">tv</span>
            <span class="n">wsum</span> <span class="o">=</span> <span class="n">tw</span>
            <span class="n">knapsack</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[:]</span>
            <span class="n">snacks</span> <span class="o">+=</span> <span class="n">go_back</span>
            <span class="k">del</span> <span class="n">snacks</span><span class="p">[</span><span class="n">cand</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">vsum</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">vsum</span>
            <span class="n">ansknapsack</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">[:]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;snacks&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ansknapsack</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">climb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">ws</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>ナップサック問題の場合、探索空間に置いて近傍が広いため、焼きなまし法と山登り法であまり結果に差がつかない。
近傍がそんなに多くない山登り法を使う巡回セールスマン問題などでは、焼きなまし法に変更することで結果が良くなることが見込める。</p>
<h4 id="_20">演習問題</h4>
<p>様々なサイズのナップサック問題を用意して、それぞれのアルゴリズムのスピードと、解答の精度を比べてみよ。</p>
<h2 id="_21">近似アルゴリズム</h2>
<p>近似アルゴリズムは多項式時間アルゴリズムのなかで、最適からそんなに離れていない解を返すことが保証されているアルゴリズムである。
たとえば、最小値の2倍よりは小さい値を返すことが保証されてるアルゴリズムは近似アルゴリズムの例であり、2-近似アルゴリズムと呼ばれる。
以下では、巡回セールスマン問題の2近似アルゴリズムを紹介する。
ただし、これらのアルゴリズムは三角不等式が成り立つことが前提となっている。</p>
<h3 id="_22">最近挿入法</h3>
<p>最近挿入法は、街0だけからなる巡回路に、いまの巡回路に近い街から順にひとつずつ巡回路に挿入していく方法である。</p>
<p>厳密には以下のようなアルゴリズムになる。</p>
<ol>
<li>S=[0]とする</li>
<li>Sに含まれる街と、それ以外の街の距離の中で、最も短いものを見つけてくる。Sに含まれる方をu, 含まれない方をvとする。</li>
<li>Sのなかでuの直後にvを挿入する。</li>
<li>全ての街がSに含まれたなら終了し、そうでないなら2に戻る。</li>
</ol>
<p>実際に実装すると以下のようになる</p>
<div class="highlight"><pre><span></span><code><span class="n">INF</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">10</span>
<span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span>


<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">route</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">used</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">neighb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">td</span> <span class="o">=</span> <span class="n">INF</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="k">continue</span>
            <span class="k">if</span> <span class="n">td</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">nxt</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">td</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">ne</span> <span class="o">=</span> <span class="n">neighb</span><span class="p">[</span><span class="n">nxt</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">route</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ne</span><span class="p">)</span>
        <span class="n">route</span> <span class="o">=</span> <span class="n">route</span><span class="p">[:</span><span class="n">ne</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">nxt</span><span class="p">]</span> <span class="o">+</span> <span class="n">route</span><span class="p">[</span><span class="n">ne</span><span class="p">:]</span>
        <span class="n">used</span><span class="p">[</span><span class="n">nxt</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="k">continue</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">nxt</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">nxt</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">neighb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">route</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">route</span> <span class="o">=</span> <span class="n">route</span><span class="p">[</span><span class="n">ind</span><span class="p">:]</span> <span class="o">+</span> <span class="n">route</span><span class="p">[:</span><span class="n">ind</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">route</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;route&quot;</span><span class="p">,</span> <span class="n">route</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div>

<h4 id="_23">演習問題</h4>
<p>自分でテストケースを作ってみて最近挿入法を試してみよ。小さいケースでは動的計画法が返す最適解と比較して、2近似になっていることを確かめよ。</p>
<h4 id="_24">演習問題</h4>
<p>2次元平面上のN点の最短巡回路をもとめて可視化してみよ。javascriptやPILやgnuplotを使っても良いが、Processingが書けるならば、Processingのコードを出力するプログラムを作るのが一番楽だろう。</p>
<h3 id="_25">大きめな入出力例</h3>
<p><a href="https://github.com/catupper/spring2019/tree/gh-pages/ja_JP/sourcecode">このページ</a>に大きめな入出力例がある。試してみよう。</p>
<h3 id="tspvisualizer">TSPのVisualizer</h3>
<p><a href="https://catupper.github.io/tsp_visualizer/tsp_visualizer">Visualizer</a>
入力の番号を選んでSetInputを押すと点が描画される。
ルートは空白区切りでめぐる順番を入れればよい。最後に出発地点を追加する必要はない。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
